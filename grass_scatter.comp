#version 450 core

layout(local_size_x = 256) in;

// packed to 32 bytes
struct GrassInstance {
    vec3  pos;
    float yaw;
    float height;
    float width;
    float phase;
    float _pad1;
};

struct TrackSegment {
    vec4 start_r; // start.xyz, radius in .w
    vec4 end_pad; // end.xyz, unused in .w
};

layout(std430, binding = 1) buffer GrassOut {
    // 16 byte header (std430)
    uint instanceCount;  // atomic counter (number of VALID grass blades)
    uint _pad0;
    uint _pad1;
    uint _pad2;
    GrassInstance instances[];  // payload starts at offset 16
};

// UBO set in ChunkManager
layout(std140, binding = 3) uniform TerrainParams {
    float u_bedrockFrequency;
    float u_bedrockAmplitude;
    float u_frequency;
    float u_frequencyMultiplier;
    float u_amplitude;
    float u_amplitudeMultiplier;
    float u_floorLevel;
    float u_blendFactor;
};

layout(std430, binding=4) readonly buffer TrackSegBuf {
    TrackSegment segments[];
};

layout(std430, binding=5) readonly buffer TrackIdxBuf {
    uint segIndices[];
};

// Uniforms
uniform int  u_instanceCount;
uniform int  u_segIndexCount;
uniform vec3  u_chunkId;
uniform float u_chunkSize;


// Tiny RNG (u32 hash)
uint hash_u32(uint x) {
    x ^= x >> 16u;
    x *= 0x7feb352du;
    x ^= x >> 15u;
    x *= 0x846ca68bu;
    x ^= x >> 16u;
    return x;
}
float rand01(inout uint s) {
    s = hash_u32(s);
    return float(s & 0x00FFFFFFu) * (1.0f / 16777216.0f); // [0,1)
}

const float PI = 3.14159265359f;

vec3 random3(vec3 c) {
	float j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));
	vec3 r;
	r.z = fract(512.0*j);
	j *= .125;
	r.x = fract(512.0*j);
	j *= .125;
	r.y = fract(512.0*j);
	return r-0.5;
}

// skew constants for 3d simplex functions
const float F3 =  0.3333333;
const float G3 =  0.1666667;

float simplex3d(vec3 p) {
	 vec3 s = floor(p + dot(p, vec3(F3)));
	 vec3 x = p - s + dot(s, vec3(G3));
	 vec3 e = step(vec3(0.0), x - x.yzx);
	 vec3 i1 = e*(1.0 - e.zxy);
	 vec3 i2 = 1.0 - e.zxy*(1.0 - e);
	 vec3 x1 = x - i1 + G3;
	 vec3 x2 = x - i2 + 2.0*G3;
	 vec3 x3 = x - 1.0 + 3.0*G3;
	 vec4 w, d;
	 w.x = dot(x, x);
	 w.y = dot(x1, x1);
	 w.z = dot(x2, x2);
	 w.w = dot(x3, x3);
	 w = max(0.6 - w, 0.0);
	 d.x = dot(random3(s), x);
	 d.y = dot(random3(s + i1), x1);
	 d.z = dot(random3(s + i2), x2);
	 d.w = dot(random3(s + 1.0), x3);
	 w *= w;
	 w *= w;
	 d *= w;

	 return dot(d, vec4(52.0));
}


float cubeVal(vec3 pos) {
   
    // Bedrock
    float noise = 0.0;
    float frequency = u_bedrockFrequency;
    float amplitude = u_bedrockAmplitude;

    for(int i = 0; i < 6; ++i){
        noise += simplex3d(pos * frequency) * amplitude;
        frequency *= u_frequencyMultiplier;
        amplitude *= u_amplitudeMultiplier;
    }
    
    return  noise  + u_floorLevel;
}

bool isUnderground(vec3 pos) {
    
    // Hills and Features  
    if(pos.y <2.0) return true;

    float noise = 0.0;
    float frequency = u_frequency;
    float amplitude = u_amplitude;

    for(int i = 0; i < 6; ++i){
        noise += simplex3d(pos * frequency) * amplitude;
        frequency *= u_frequencyMultiplier;
        amplitude *= u_amplitudeMultiplier;
    }

    float terrainDensity = -pos.y + noise + u_floorLevel;

    if(terrainDensity > 0.0) return true;
    return false;
}

// distance from p to capsule along AB with radius r
float sdCapsule(vec3 p, vec3 a, vec3 b, float r) {
    vec3 pa = p - a, ba = b - a;
    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);
    float d = length(pa - ba * h) - r;
    return d; // < 0 => inside
}

bool insideTrack(vec3 p) {
    if(u_segIndexCount == 0) return false;

    // small, per-chunk loop
    for (uint k = 0; k < u_segIndexCount; ++k) {
        uint idx = segIndices[k];
        vec3 a = segments[idx].start_r.xyz;
        float r = segments[idx].start_r.w;
        vec3 b = segments[idx].end_pad.xyz;
        if (sdCapsule(p, a, b, r) < 0.0) return true;
    }
    return false;
}


void main() {
    uint gid = gl_GlobalInvocationID.x;
    if (gid >= u_instanceCount) return;

    float fN  = float(u_instanceCount);
    uint side = uint(ceil(sqrt(fN)));      // grid side = ceil(sqrt(N))
    uint ix   =  gid % side;
    uint iz   =  gid / side;

    float cellSize = u_chunkSize / float(side);

    // jitter in [-0.5*cell, +0.5*cell]
    float jx = (rand01(gid) - 0.5f) * cellSize;
    float jz = (rand01(gid) - 0.5f) * cellSize;

    // cell center inside the chunk
    float baseX = (float(ix) + 0.5f) * cellSize;
    float baseZ = (float(iz) + 0.5f) * cellSize;

    // world pos
    float wx = u_chunkId.x * u_chunkSize + baseX + jx;
    float wz = u_chunkId.z * u_chunkSize + baseZ + jz;
    float wy = cubeVal(vec3(wx, 0.0, wz)); // sample bedrock height
    vec3 pos = vec3(wx, wy, wz);

    // skip writing if blade is underground or inside the track
    if (isUnderground(pos)) { return; }

    float jitterScale = 40.0;
    if (insideTrack(vec3(pos.x + simplex3d(pos)*jitterScale, pos.y, pos.z + simplex3d(pos)*jitterScale))) { return; }

    // other params
    float yaw    = rand01(gid) * (2.0f * PI);
    float height = mix(3.75f, 4.35f, rand01(gid));
    float width  = mix(1.60f, 2.20f, rand01(gid));
    float phase  = rand01(gid) * (2.0f * PI);


    // create grass instance
    GrassInstance gi;
    gi.pos    = pos;
    gi.yaw    = yaw;
    gi.height = height;
    gi.width  = width;
    gi.phase  = phase;
    gi._pad1  = 0.0f;

    // reserve slot and write
    uint idx = atomicAdd(instanceCount, 1u);
    instances[idx] = gi;
}
