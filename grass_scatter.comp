#version 450 core

layout(local_size_x = 256) in;

struct GrassInstance {
    vec3  pos;
    float yaw;
    float height;
    float width;
    float phase;
    float _pad;
};

struct TrackSegment {
    vec4 start_r; // start.xyz, radius in .w
    vec4 end_pad; // end.xyz, unused in .w
};

layout(std430, binding = 1) buffer GrassOut {
    // 16 byte header (std430)
    uint instanceCount;  // atomic counter (number of VALID grass blades)
    uint _pad0;
    uint _pad1;
    uint _pad2;
    GrassInstance instances[];  // payload starts at offset 16
};

layout(std140, binding = 2) uniform Lighting {
    vec4 u_lightDir;
    vec4 u_lightLa;
    vec4 u_lightLe;
};

// UBO set in ChunkManager
layout(std140, binding = 3) uniform TerrainParams {
    float u_bedrockFrequency;
    float u_bedrockAmplitude;
    float u_frequency;
    float u_frequencyMultiplier;
    float u_amplitude;
    float u_amplitudeMultiplier;
    float u_floorLevel;
    float u_blendFactor;
    float u_warpFreq;
    float u_warpAmp;
    float u_warpStrength;
    float u_warpFreqMult;
    float u_warpAmpMult; 
    int u_warpOctaves;
    int u_seed;
    float u_waterLevel;
};

layout(std430, binding=4) readonly buffer TrackSegBuf {
    TrackSegment segments[];
};

layout(std430, binding=5) readonly buffer TrackIdxBuf {
    uint segIndices[];
};

// Uniforms
uniform int  u_instanceCount;
uniform int  u_segIndexCount;
uniform vec3  u_chunkId;
uniform float u_chunkSize;

// ---------- Seed ----------
vec3 seedOffset(int s) {
    return vec3(
        float(s) * 127.1 + 311.7,
        float(s) * 269.5 + 183.3,
        float(s) * 419.2 + 247.0
    );
}

// ---------- Noise ----------
const float PI = 3.14159265359f;

uint hash_u32(uint x) {
    x ^= x >> 16u;
    x *= 0x7feb352du;
    x ^= x >> 15u;
    x *= 0x846ca68bu;
    x ^= x >> 16u;
    return x;
}

float rand01(inout uint s) {
    s = hash_u32(s);
    return float(s & 0x00FFFFFFu) * (1.0f / 16777216.0f); // [0,1)
}

vec3 random3(vec3 c) {
	float j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));
	vec3 r;
	r.z = fract(512.0*j);
	j *= .125;
	r.x = fract(512.0*j);
	j *= .125;
	r.y = fract(512.0*j);
	return r-0.5;
}

// Skew constants for 3d simplex functions
const float F3 =  0.3333333;
const float G3 =  0.1666667;
float simplex3d(vec3 p) {
	 vec3 s = floor(p + dot(p, vec3(F3)));
	 vec3 x = p - s + dot(s, vec3(G3));
	 vec3 e = step(vec3(0.0), x - x.yzx);
	 vec3 i1 = e*(1.0 - e.zxy);
	 vec3 i2 = 1.0 - e.zxy*(1.0 - e);
	 vec3 x1 = x - i1 + G3;
	 vec3 x2 = x - i2 + 2.0*G3;
	 vec3 x3 = x - 1.0 + 3.0*G3;
	 vec4 w, d;
	 w.x = dot(x, x);
	 w.y = dot(x1, x1);
	 w.z = dot(x2, x2);
	 w.w = dot(x3, x3);
	 w = max(0.6 - w, 0.0);
	 d.x = dot(random3(s), x);
	 d.y = dot(random3(s + i1), x1);
	 d.z = dot(random3(s + i2), x2);
	 d.w = dot(random3(s + 1.0), x3);
	 w *= w;
	 w *= w;
	 d *= w;

	 return dot(d, vec4(52.0));
}

float fbmSimplex3D(vec3 p, float freq, float amp, float fMul, float aMul, int octs) {
    p += seedOffset(u_seed);

    float acc = 0.0;
    for (int i = 0; i < octs; ++i) {
        acc += simplex3d(p * freq) * amp;
        freq *= fMul;
        amp  *= aMul;
    }
    return acc;
}

// 2-channel domain warp on XZ; Y stays unchanged to avoid vertical folding
vec3 warpXZ(vec3 p, float baseFreq, float baseAmp, float freqMul, float ampMul, int octs, float strength) {
    // First pass
    float qx = fbmSimplex3D(vec3(p.x,  0.0, p.z) + vec3( 37.0, 11.0, 19.0), baseFreq, baseAmp, freqMul, ampMul, octs);
    float qz = fbmSimplex3D(vec3(p.x,  0.0, p.z) + vec3(-23.0,  5.0, 41.0), baseFreq, baseAmp, freqMul, ampMul, octs);

    // Second pass
    vec2 q  = vec2(qx, qz);
    float rx = fbmSimplex3D(vec3(p.x + q.x, 0.0, p.z + q.y) + vec3( 13.0,  7.0, -9.0), baseFreq, baseAmp, freqMul, ampMul, max(octs-1, 1));
    float rz = fbmSimplex3D(vec3(p.x - q.y, 0.0, p.z + q.x) + vec3(-29.0, -3.0, 17.0), baseFreq, baseAmp, freqMul, ampMul, max(octs-1, 1));

    vec3 outP = p;
    outP.x += rx * strength;
    outP.z += rz * strength;
    return outP;
}


// ---------- Track ----------
// Distance from p to capsule along AB with radius r
float sdCapsule(vec3 p, vec3 a, vec3 b, float r) {
    vec3 pa = p - a, ba = b - a;
    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);
    float d = length(pa - ba * h) - r;
    return d; // < 0 => inside
}

// Track mask: 0 inside road, 1 outside, smooth with u_blendFactor
float trackMask(vec3 p) {
    if (u_segIndexCount == 0) return 1.0;

    float w = 1.0;
    // Combine influence of segments with min()
    for (uint k = 0; k < u_segIndexCount; ++k) {
        uint idx = segIndices[k];
        vec3 a = segments[idx].start_r.xyz;
        float r = segments[idx].start_r.w;
        vec3 b = segments[idx].end_pad.xyz;

        float d = sdCapsule(p, a, b, r); // <0 inside capsule
        float wSeg = smoothstep(-u_blendFactor, +u_blendFactor, d);
        w = min(w, wSeg);
    }
    return w;
}


// ---------- Terrain density ----------
float bedrockDensityAt(vec3 pos) {
    // Bedrock
    float bedrockNoise = fbmSimplex3D(vec3(pos.x, 0.0, pos.z), u_bedrockFrequency, u_bedrockAmplitude, u_frequencyMultiplier, u_amplitudeMultiplier, u_warpOctaves);
    float bedrockDensity = -pos.y + bedrockNoise + u_floorLevel;

    return bedrockDensity;
}

float hillDensityAt(vec3 pos) {
     // Hills and Features
    vec3 hpos = warpXZ(pos, u_warpFreq, u_warpAmp, u_warpFreqMult, u_warpAmpMult, u_warpOctaves, u_warpStrength);
    float hillNoise = fbmSimplex3D(hpos, u_frequency, u_amplitude, u_frequencyMultiplier, u_amplitudeMultiplier, u_warpOctaves);
    float terrainDensity = -pos.y + hillNoise;

    return terrainDensity;
}

float densityAt(vec3 pos) {    
    // Bedrock
    float bedrockNoise = fbmSimplex3D(vec3(pos.x, 0.0, pos.z), u_bedrockFrequency, u_bedrockAmplitude, u_frequencyMultiplier, u_amplitudeMultiplier, u_warpOctaves);
    float bedrockDensity = -pos.y + bedrockNoise + u_floorLevel;

    // Hills and Features
    vec3 hpos = warpXZ(pos, u_warpFreq, u_warpAmp, u_warpFreqMult, u_warpAmpMult, u_warpOctaves, u_warpStrength);
    float hillNoise = fbmSimplex3D(hpos, u_frequency, u_amplitude, u_frequencyMultiplier, u_amplitudeMultiplier, u_warpOctaves);
    float terrainDensity = -pos.y + hillNoise;

    // Combined terrain with track mask
    float blendedDensity = max(bedrockDensity, terrainDensity);
    return mix(bedrockDensity, blendedDensity, trackMask(pos));
}


// ---------- Main ----------
void main() {
    uint gid = gl_GlobalInvocationID.x;
    if (gid >= u_instanceCount) return;

    float fN  = float(u_instanceCount);
    uint side = uint(ceil(sqrt(fN)));      // grid side = ceil(sqrt(N))
    uint ix   =  gid % side;
    uint iz   =  gid / side;

    float cellSize = u_chunkSize / float(side);

    // Jitter in [-0.5*cell, +0.5*cell]
    float jx = (rand01(gid) - 0.5) * cellSize;
    float jz = (rand01(gid) - 0.5) * cellSize;

    // Cell center inside the chunk
    float baseX = (float(ix) + 0.5) * cellSize;
    float baseZ = (float(iz) + 0.5) * cellSize;

    // World pos
    float wx = u_chunkId.x * u_chunkSize + baseX + jx;
    float wz = u_chunkId.z * u_chunkSize + baseZ + jz;
    float wy = bedrockDensityAt(vec3(wx, 0.0, wz));
    vec3 pos = vec3(wx, wy, wz);

    // Skip writing if blade is underground or inside the track
    if(pos.y < u_waterLevel + 2.0) { return; } // too close to water
    if (hillDensityAt(pos) > 0.0) { return; } // under hills
    if (trackMask(vec3(pos.x + simplex3d(pos) * 40.0, pos.y, pos.z + simplex3d(pos) * 40.0)) < 0.4) { return; } // inside track

    // Other params
    float yaw    = rand01(gid) * (2.0 * PI);
    float height = mix(3.75, 4.35, rand01(gid));
    float width  = mix(2.60, 3.20, rand01(gid));
    float phase  = rand01(gid) * (2.0 * PI);


    // Create grass instance
    GrassInstance gi;
    gi.pos    = pos;
    gi.yaw    = yaw;
    gi.height = height;
    gi.width  = width;
    gi.phase  = phase;

    // Reserve slot and write
    uint idx = atomicAdd(instanceCount, 1u);
    instances[idx] = gi;
}
