#version 450 core

layout(local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

struct TrackSegment {
    vec4 start_r; // start.xyz, radius in .w
    vec4 end_pad; // end.xyz, unused in .w
};

layout(std430, binding = 0) buffer VertexBuffer {
    uint vertexCount;   // counts vertices written (multiple of 3)
    uint _pad0;         // pad to 16 bytes for std430 alignment
    uint _pad1;
    uint _pad2;
    vec4 vertices[];    // payload starts at offset 16
};

layout(std140, binding = 3) uniform TerrainParams {
    float u_bedrockFrequency;
    float u_bedrockAmplitude;
    float u_frequency;
    float u_frequencyMultiplier;
    float u_amplitude;
    float u_amplitudeMultiplier;
    float u_floorLevel;
    float u_blendFactor;
};

layout(std430, binding=4) readonly buffer TrackSegBuf {
    TrackSegment segments[];
};

layout(std430, binding=5) readonly buffer TrackIdxBuf {
    uint segIndices[];
};

uniform vec3 chunkID;
uniform float chunkSize;
uniform int tesselation;
uniform int u_segIndexCount;
uniform isampler2D edgeTableTex;
uniform isampler2D triTableTex;

float isolevel = 0.0;

vec4[8] corners = {
	vec4(0, 0, 0, 0),
	vec4(1, 0, 0, 0),
	vec4(1, 1, 0, 0),
	vec4(0, 1, 0, 0),
    vec4(0, 0, 1, 0),
	vec4(1, 0, 1, 0),
	vec4(1, 1, 1, 0),
	vec4(0, 1, 1, 0)
};

vec3 random3(vec3 c) {
	float j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));
	vec3 r;
	r.z = fract(512.0*j);
	j *= .125;
	r.x = fract(512.0*j);
	j *= .125;
	r.y = fract(512.0*j);
	return r-0.5;
}

// skew constants for 3d simplex functions
const float F3 =  0.3333333;
const float G3 =  0.1666667;

float simplex3d(vec3 p) {
	 vec3 s = floor(p + dot(p, vec3(F3)));
	 vec3 x = p - s + dot(s, vec3(G3));
	 vec3 e = step(vec3(0.0), x - x.yzx);
	 vec3 i1 = e*(1.0 - e.zxy);
	 vec3 i2 = 1.0 - e.zxy*(1.0 - e);
	 vec3 x1 = x - i1 + G3;
	 vec3 x2 = x - i2 + 2.0*G3;
	 vec3 x3 = x - 1.0 + 3.0*G3;
	 vec4 w, d;
	 w.x = dot(x, x);
	 w.y = dot(x1, x1);
	 w.z = dot(x2, x2);
	 w.w = dot(x3, x3);
	 w = max(0.6 - w, 0.0);
	 d.x = dot(random3(s), x);
	 d.y = dot(random3(s + i1), x1);
	 d.z = dot(random3(s + i2), x2);
	 d.w = dot(random3(s + 1.0), x3);
	 w *= w;
	 w *= w;
	 d *= w;

	 return dot(d, vec4(52.0));
}

// distance from p to capsule along AB with radius r (source: https://iquilezles.org/articles/distfunctions/)
float sdCapsule(vec3 p, vec3 a, vec3 b, float r) {
    vec3 pa = p - a, ba = b - a;
    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);
    float d = length(pa - ba * h) - r;
    return d; // <0 inside capsule
}

// soft mask: 0 inside road, 1 outside, smooth with u_blendFactor
float insideTrack(vec3 p) {
    if (u_segIndexCount == 0) return 1.0;

    float w = 1.0;
    // Combine influence of segments with min()
    for (uint k = 0; k < u_segIndexCount; ++k) {
        uint idx = segIndices[k];
        vec3 a = segments[idx].start_r.xyz;
        float r = segments[idx].start_r.w;
        vec3 b = segments[idx].end_pad.xyz;

        float d = sdCapsule(p, a, b, r); // <0 inside capsule
        float wSeg = smoothstep(-u_blendFactor, +u_blendFactor, d);
        w = min(w, wSeg);
    }
    return w;
}

float cubeVal(int cornerIdx) {
    vec3 pos = vec3(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y, gl_GlobalInvocationID.z) + corners[cornerIdx].xyz;
    pos *= chunkSize / float(tesselation);
    pos += chunkID * chunkSize;
    
    // Bedrock
    float noise = 0.0; // Accumulator
    float frequency = u_bedrockFrequency;
    float amplitude = u_bedrockAmplitude;

    for(int i = 0; i < 6; ++i){
        noise += simplex3d(pos * frequency) * amplitude;
        frequency *= u_frequencyMultiplier;
        amplitude *= u_amplitudeMultiplier;
    }

    float bedrockDensity = -pos.y + noise + u_floorLevel;

    // Hills and Features
    noise = 0.0;
    frequency = u_frequency;
    amplitude = u_amplitude;

    for(int i = 0; i < 6; ++i){
        noise += simplex3d(pos * frequency) * amplitude;
        frequency *= u_frequencyMultiplier;
        amplitude *= u_amplitudeMultiplier;
    }

    float terrainDensity = -pos.y + noise;

    // Combined terrain
    float blendedTerrain = max(terrainDensity, bedrockDensity);

    // Road soft mask 
    float w = insideTrack(pos); // 0 inside road, 1 outside
    float finalDensity = mix(bedrockDensity, blendedTerrain, w);

    return finalDensity;
}

vec3 cubePos(int cornerIdx) {
    vec3 pos = vec3(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y, gl_GlobalInvocationID.z) + corners[cornerIdx].xyz;
    pos *= chunkSize / float(tesselation);
    pos += chunkID * chunkSize;

    return pos;
}

vec3 vertexInterp(float isolevel, vec3 v0, float l0, vec3 v1, float l1) {
    return mix(v0, v1, (isolevel - l0) / (l1 - l0));
}

int triTableValue(int i, int j) {
    return texelFetch(triTableTex, ivec2(j, i), 0).r;
}

 

void main() {
    float cubeVal0 = cubeVal(0);
    float cubeVal1 = cubeVal(1);
    float cubeVal2 = cubeVal(2);
    float cubeVal3 = cubeVal(3);
    float cubeVal4 = cubeVal(4);
    float cubeVal5 = cubeVal(5);
    float cubeVal6 = cubeVal(6);
    float cubeVal7 = cubeVal(7);

    int cubeindex=0;
    cubeindex += int(cubeVal0 < isolevel);
    cubeindex += int(cubeVal1 < isolevel)*2;
    cubeindex += int(cubeVal2 < isolevel)*4;
    cubeindex += int(cubeVal3 < isolevel)*8;
    cubeindex += int(cubeVal4 < isolevel)*16;
    cubeindex += int(cubeVal5 < isolevel)*32;
    cubeindex += int(cubeVal6 < isolevel)*64;
    cubeindex += int(cubeVal7 < isolevel)*128;
    if (cubeindex ==0 || cubeindex == 255) return;

    vec3 vertlist[12];
    vertlist[0] = vertexInterp(isolevel, cubePos(0), cubeVal0, cubePos(1), cubeVal1);
    vertlist[1] = vertexInterp(isolevel, cubePos(1), cubeVal1, cubePos(2), cubeVal2);
    vertlist[2] = vertexInterp(isolevel, cubePos(2), cubeVal2, cubePos(3), cubeVal3);
    vertlist[3] = vertexInterp(isolevel, cubePos(3), cubeVal3, cubePos(0), cubeVal0);
    vertlist[4] = vertexInterp(isolevel, cubePos(4), cubeVal4, cubePos(5), cubeVal5);
    vertlist[5] = vertexInterp(isolevel, cubePos(5), cubeVal5, cubePos(6), cubeVal6);
    vertlist[6] = vertexInterp(isolevel, cubePos(6), cubeVal6, cubePos(7), cubeVal7);
    vertlist[7] = vertexInterp(isolevel, cubePos(7), cubeVal7, cubePos(4), cubeVal4);
    vertlist[8] = vertexInterp(isolevel, cubePos(0), cubeVal0, cubePos(4), cubeVal4);
    vertlist[9] = vertexInterp(isolevel, cubePos(1), cubeVal1, cubePos(5), cubeVal5);
    vertlist[10] = vertexInterp(isolevel, cubePos(2), cubeVal2, cubePos(6), cubeVal6);
    vertlist[11] = vertexInterp(isolevel, cubePos(3), cubeVal3, cubePos(7), cubeVal7);

    int i=0;
     while (true) {
        int t0 = triTableValue(cubeindex, i+0);
        if (t0 == -1) break;

        int t1 = triTableValue(cubeindex, i+1);
        int t2 = triTableValue(cubeindex, i+2);

        // Reserve 3 slots atomically
        uint base = atomicAdd(vertexCount, 3u);

        vertices[base + 0u] = vec4(vertlist[t0], 1.0);
        vertices[base + 1u] = vec4(vertlist[t1], 1.0);
        vertices[base + 2u] = vec4(vertlist[t2], 1.0);

        i += 3;
    }
}