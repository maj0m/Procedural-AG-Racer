#version 450 core

layout(local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

struct TrackSegment {
    vec4 start_r; // start.xyz, radius in .w
    vec4 end_pad; // end.xyz, unused in .w
};

layout(std430, binding = 0) buffer VertexBuffer {
    uint vertexCount;   // counts vertices written (multiple of 3)
    uint _pad0;         // pad to 16 bytes for std430 alignment
    uint _pad1;
    uint _pad2;
    vec4 vertices[];    // payload starts at offset 16
};

layout(std140, binding = 2) uniform Lighting {
    vec4 u_lightDir;
    vec4 u_lightLa;
    vec4 u_lightLe;
};

// UBO set in ChunkManager
layout(std140, binding = 3) uniform TerrainParams {
    float u_bedrockFrequency;
    float u_bedrockAmplitude;
    float u_frequency;
    float u_frequencyMultiplier;
    float u_amplitude;
    float u_amplitudeMultiplier;
    float u_floorLevel;
    float u_blendFactor;
    float u_warpFreq;
    float u_warpAmp;
    float u_warpStrength;
    float u_warpFreqMult;
    float u_warpAmpMult; 
    int u_warpOctaves;
    int u_seed;
    float _pad4;
};

layout(std430, binding=4) readonly buffer TrackSegBuf {
    TrackSegment segments[];
};

layout(std430, binding=5) readonly buffer TrackIdxBuf {
    uint segIndices[];
};

// Uniforms
uniform vec3 chunkID;
uniform float chunkSize;
uniform int tesselation;
uniform int u_segIndexCount;
uniform isampler2D edgeTableTex;
uniform isampler2D triTableTex;

// Terrain density treshold
const float isolevel = 0.0;

// Corner offsets of a unit cube
const vec3 CORNERS[8] = vec3[8](
    vec3(0,0,0), vec3(1,0,0), vec3(1,1,0), vec3(0,1,0),
    vec3(0,0,1), vec3(1,0,1), vec3(1,1,1), vec3(0,1,1)
);

// ---------- Seed ----------
vec3 seedOffset(int s) {
    return vec3(
        float(s) * 127.1 + 311.7,
        float(s) * 269.5 + 183.3,
        float(s) * 419.2 + 247.0
    );
}

// ---------- Noise ----------
vec3 random3(vec3 c) {
	float j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));
	vec3 r;
	r.z = fract(512.0*j);
	j *= .125;
	r.x = fract(512.0*j);
	j *= .125;
	r.y = fract(512.0*j);
	return r-0.5;
}

// Skew constants for 3d simplex functions
const float F3 =  0.3333333;
const float G3 =  0.1666667;
float simplex3d(vec3 p) {
	 vec3 s = floor(p + dot(p, vec3(F3)));
	 vec3 x = p - s + dot(s, vec3(G3));
	 vec3 e = step(vec3(0.0), x - x.yzx);
	 vec3 i1 = e*(1.0 - e.zxy);
	 vec3 i2 = 1.0 - e.zxy*(1.0 - e);
	 vec3 x1 = x - i1 + G3;
	 vec3 x2 = x - i2 + 2.0*G3;
	 vec3 x3 = x - 1.0 + 3.0*G3;
	 vec4 w, d;
	 w.x = dot(x, x);
	 w.y = dot(x1, x1);
	 w.z = dot(x2, x2);
	 w.w = dot(x3, x3);
	 w = max(0.6 - w, 0.0);
	 d.x = dot(random3(s), x);
	 d.y = dot(random3(s + i1), x1);
	 d.z = dot(random3(s + i2), x2);
	 d.w = dot(random3(s + 1.0), x3);
	 w *= w;
	 w *= w;
	 d *= w;

	 return dot(d, vec4(52.0));
}

float fbmSimplex3D(vec3 p, float freq, float amp, float fMul, float aMul, int octs) {
    p += seedOffset(u_seed);

    float acc = 0.0;
    for (int i = 0; i < octs; ++i) {
        acc += simplex3d(p * freq) * amp;
        freq *= fMul;
        amp  *= aMul;
    }
    return acc;
}

// 2-channel domain warp on XZ; Y stays unchanged to avoid vertical folding
vec3 warpXZ(vec3 p, float baseFreq, float baseAmp, float freqMul, float ampMul, int octs, float strength) {
    // First pass
    float qx = fbmSimplex3D(vec3(p.x,  0.0, p.z) + vec3( 37.0, 11.0, 19.0), baseFreq, baseAmp, freqMul, ampMul, octs);
    float qz = fbmSimplex3D(vec3(p.x,  0.0, p.z) + vec3(-23.0,  5.0, 41.0), baseFreq, baseAmp, freqMul, ampMul, octs);

    // Second pass
    vec2 q  = vec2(qx, qz);
    float rx = fbmSimplex3D(vec3(p.x + q.x, 0.0, p.z + q.y) + vec3( 13.0,  7.0, -9.0), baseFreq, baseAmp, freqMul, ampMul, max(octs-1, 1));
    float rz = fbmSimplex3D(vec3(p.x - q.y, 0.0, p.z + q.x) + vec3(-29.0, -3.0, 17.0), baseFreq, baseAmp, freqMul, ampMul, max(octs-1, 1));

    vec3 outP = p;
    outP.x += rx * strength;
    outP.z += rz * strength;
    return outP;
}


// ---------- Track mask ----------
// Distance from p to capsule along AB with radius r (source: https://iquilezles.org/articles/distfunctions/)
float sdCapsule(vec3 p, vec3 a, vec3 b, float r) {
    vec3 pa = p - a, ba = b - a;
    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);
    float d = length(pa - ba * h) - r;
    return d; // <0 inside capsule
}


// Track mask: 0 inside road, 1 outside, smooth with u_blendFactor
float trackMask(vec3 p) {
    if (u_segIndexCount == 0) return 1.0;

    float w = 1.0;
    // Combine influence of segments with min()
    for (uint k = 0; k < u_segIndexCount; ++k) {
        uint idx = segIndices[k];
        vec3 a = segments[idx].start_r.xyz;
        float r = segments[idx].start_r.w;
        vec3 b = segments[idx].end_pad.xyz;

        float d = sdCapsule(p, a, b, r); // <0 inside capsule
        float wSeg = smoothstep(-u_blendFactor, +u_blendFactor, d);
        w = min(w, wSeg);
    }
    return w;
}


// ---------- Terrain density ----------
float densityAt(vec3 pos) {    
    // Bedrock
    float bedrockNoise = fbmSimplex3D(vec3(pos.x, 0.0, pos.z), u_bedrockFrequency, u_bedrockAmplitude, u_frequencyMultiplier, u_amplitudeMultiplier, u_warpOctaves);
    float bedrockDensity = -pos.y + bedrockNoise + u_floorLevel;

    // Hills and Features
    vec3 hpos = warpXZ(pos, u_warpFreq, u_warpAmp, u_warpFreqMult, u_warpAmpMult, u_warpOctaves, u_warpStrength);
    float hillNoise = fbmSimplex3D(hpos, u_frequency, u_amplitude, u_frequencyMultiplier, u_amplitudeMultiplier, u_warpOctaves);
    float terrainDensity = -pos.y + hillNoise;

    // Combined terrain with track mask
    float blendedDensity = max(bedrockDensity, terrainDensity);
    return mix(bedrockDensity, blendedDensity, trackMask(pos));
}


// ---------- Shadow Ray-Marcher ----------
bool isInShadow(vec3 wPos) {
    vec3 rayDir = normalize(u_lightDir.xyz);

    // Small bias to avoid self-hits
    const float eps = 10.0;
    vec3 p = wPos + rayDir * eps;

    // Fixed-step march
    const float stepLen  = 10.0;
    const int   maxSteps = 100;

    for (int i = 0; i < maxSteps; ++i) {
        if (p.y > 200.0) return false;          // escaped above terrain
        if (densityAt(p) > 0.0) return true;    // hit
        p += rayDir * stepLen;
    }
    return false; // no hit
}


// ---------- Marching cubes helpers ----------
vec3 worldCornerPos(int cornerIdx, vec3 baseWorld, float scale) {
    return baseWorld + CORNERS[cornerIdx] * scale;
}

vec3 vertexInterp(float isolevel, vec3 v0, float l0, vec3 v1, float l1) {
    return mix(v0, v1, (isolevel - l0) / (l1 - l0));
}

int triTableValue(int i, int j) {
    return texelFetch(triTableTex, ivec2(j, i), 0).r;
}


 // ---------- Main ----------
void main() {

    // Cell origin in world space
    vec3 cell = vec3(gl_GlobalInvocationID) * (chunkSize / float(tesselation));
    vec3 baseWorld = chunkID * chunkSize;
    float scale = chunkSize / float(tesselation);

    // Evaluate cube corners
    vec3  pos[8];
    float val[8];
    for (int i = 0; i < 8; ++i) {
        pos[i] = worldCornerPos(i, baseWorld + cell, scale);
        val[i] = densityAt(pos[i]);
    }

    // Build cube index
    int cubeIndex = 0;
    for (int i = 0; i < 8; ++i)
        cubeIndex |= (val[i] < isolevel ? 1 : 0) << i;
    if (cubeIndex == 0 || cubeIndex == 255) return;

    // Interpolate edge vertices
    vec3 vertlist[12];
    vertlist[ 0] = vertexInterp(isolevel, pos[0], val[0], pos[1], val[1]);
    vertlist[ 1] = vertexInterp(isolevel, pos[1], val[1], pos[2], val[2]);
    vertlist[ 2] = vertexInterp(isolevel, pos[2], val[2], pos[3], val[3]);
    vertlist[ 3] = vertexInterp(isolevel, pos[3], val[3], pos[0], val[0]);
    vertlist[ 4] = vertexInterp(isolevel, pos[4], val[4], pos[5], val[5]);
    vertlist[ 5] = vertexInterp(isolevel, pos[5], val[5], pos[6], val[6]);
    vertlist[ 6] = vertexInterp(isolevel, pos[6], val[6], pos[7], val[7]);
    vertlist[ 7] = vertexInterp(isolevel, pos[7], val[7], pos[4], val[4]);
    vertlist[ 8] = vertexInterp(isolevel, pos[0], val[0], pos[4], val[4]);
    vertlist[ 9] = vertexInterp(isolevel, pos[1], val[1], pos[5], val[5]);
    vertlist[10] = vertexInterp(isolevel, pos[2], val[2], pos[6], val[6]);
    vertlist[11] = vertexInterp(isolevel, pos[3], val[3], pos[7], val[7]);

    int i=0;
     while (true) {
        int t0 = triTableValue(cubeIndex, i+0);
        if (t0 == -1) break;
        int t1 = triTableValue(cubeIndex, i+1);
        int t2 = triTableValue(cubeIndex, i+2);

        // Reserve 3 slots atomically
        uint base = atomicAdd(vertexCount, 3u);

        // Positions
        vec3 p0 = vertlist[t0];
        vec3 p1 = vertlist[t1];
        vec3 p2 = vertlist[t2];

        // Triangle center
        vec3 triCenter = (p0 + p1 + p2) * (1.0 / 3.0);

        // Baked shadow
        float shadowFlag = isInShadow(triCenter) ? 1.0 : 0.0;

        // Write vertices; store shadow in .w
        vertices[base + 0u] = vec4(p0, shadowFlag);
        vertices[base + 1u] = vec4(p1, shadowFlag);
        vertices[base + 2u] = vec4(p2, shadowFlag);

        i += 3;
    }
}